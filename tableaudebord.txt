Derni√®re mise √† jour: {now}

## Objectif
Construire un s√©quenceur MIDI (esprit Elektron) sur STM32F429ZI (Nucleo-144) avec ChibiOS 21.11.x, capable d‚Äô√©mettre et de recevoir du MIDI via :
- USB MIDI device (Audio/MIDI 1.0),
- DIN MIDI (UART2 @ 31250 bauds),
- Horloge musicale pr√©cise 24 PPQN pilot√©e par timer mat√©riel (GPT),
- Architecture extensible style Ksoloti/Axoloti (router p√©riph√©riques, parsers robustes, SysEx, multi-ports).

Ce document d√©crit EXACTEMENT l‚Äô√©tat du projet, ce qui est valid√© sur hardware, et la suite. L‚Äôassistant doit pouvoir agir imm√©diatement sans reposer de questions tranch√©es.

---

## √âtat ACTUEL (valid√© sur hardware)
- **USB stable & r√©-√©num√©ration** au boot : d√©connexion ‚Üí pause ‚Üí `usbStart()` ‚Üí mode device forc√© (d√©sactivation VBUS sensing) ‚Üí `usbConnect()`. L‚Äôh√¥te voit un device **USB‚ÄëMIDI**.
- **Descripteurs USB** : IF0 = AudioControl, IF1 = MIDIStreaming. **EP1 OUT (Bulk, 64)** + **EP2 IN (Bulk, 64)**. Device class au niveau **interface** (0x00).
- **API MIDI unifi√©e** : `midi_note_on/off`, `midi_cc`, `midi_pitchbend`, `midi_start/stop/continue/clock` avec `midi_dest_t {{ NONE, UART, USB, BOTH }}`.
- **USB TX non bloquant (voie normale)** : messages MIDI (1‚Äì3 octets) ‚Üí paquet USB‚ÄëMIDI 4 octets (CIN correct) ‚Üí **mailbox** (msg 32 bits) ‚Üí **thread TX** agr√®ge jusqu‚Äô√† 64 octets (16 paquets) et **flushe** au plus tard √† **1 ms**. Fin de transfert : **`ep2_in_cb()`** ‚Üí **`chBSemSignalI(&tx_sem)`** ‚Üí relance (LED4).
- **Flush imm√©diat non bloquant des realtime** :
  - `0xF8` (**Clock**) : envoi imm√©diat si `usb_midi_tx_ready` + EP libre, sinon **drop** (sans bloquer) et **cr√©dit** de rattrapage.
  - `FA/FB/FC/FE/FF` (**Start/Continue/Stop/ActiveSense/Reset**) : **micro‚Äëtimeout** (200 ¬µs, configurable) pour attraper l‚ÄôEP ; √† d√©faut, **fallback mailbox** (non bloquant, avec *drop‚Äëoldest* local pour FA/FB/FC).
- **Coalescence / rattrapage Clock F8** : si des F8 ont √©t√© dropp√©es, le prochain flush imm√©diat F8 exp√©die **un petit burst** (jusqu‚Äô√† 4 F8 suppl√©mentaires, configurable) **dans la m√™me transaction USB**. Objectif : compenser proprement sans saturer l‚Äôh√¥te.
- **Packaging USB‚ÄëMIDI correct** : mapping CIN (NoteOff=0x8, NoteOn=0x9, CC=0xB, PB=0xE, Realtime=0xF) + **z√©ro‚Äëpadding** pour les messages 1 octet.
- **DIN OUT** : en parall√®le via `sdWrite(&SD2, ...)` (UART2 @ 31250 bauds).
- **Horloge 24 PPQN hardware** : **GPT TIM3** base 1 MHz (r√©solution 1 ¬µs), ISR courte qui `signalI` un s√©maphore ; **thread `midi_clk`** (prio `NORMALPRIO+1`) bascule LED1 et appelle `midi_clock(MIDI_DEST_BOTH)`.
- **`midi_set_bpm(float)`** : recalcule la p√©riode et **reprogramme** le GPT (stop‚Üístart). Valid√© sur 60/90/120/150 BPM (Ableton en esclave clock).
- **LEDs debug** : LED1 (PG10) : tick clock ; LED2 (PG9) : enqueue USB ; LED3 (PD7) : d√©part transfert USB ; LED4 (PD6) : ACK host.
- **Robustesse USB** : en √©tat UNCONFIGURED/RESET/SUSPEND ‚Üí **garanties non‚Äëblocantes** (garde `usb_midi_tx_ready`, `usb_not_ready_drops`).

**R√©sultat utilisateur** : Ableton re√ßoit clock + notes. BPM correct, transport fiable, pas de blocage si l‚ÄôUSB tombe.

---

## Fichiers PERTINENTS
- `main.c` : init HAL/RT, init USB (d√©co/reco + mode device forc√©), `midi_init()`, attente `USB_ACTIVE`, smoke test non bloquant, init horloge (`midi_clock_init()`, `midi_set_bpm()`, `midi_clock_start()`), thread d√©mo notes.
- `usbcfg.c/h` : descripteurs Audio/MIDI 1.0, EP configs, `USB_EVENT_CONFIGURED` ‚Üí `usbInitEndpointI(EP1 OUT/EP2 IN)` + `usbStartReceiveI(EP1 OUT, ...)` + **prime `tx_sem`**, gestion **`usb_midi_tx_ready`**.
- `midi.c/h` : API + **mailbox non bloquante** + **thread TX** + **s√©maphore** + mapping CIN + **flush imm√©diat non bloquant realtime** + **coalescence F8** + **micro‚Äëtimeout FA/FB/FC** + envoi DIN + **compteurs stats**.
- `midi_clock.c/h` : GPT TIM3 1 MHz, ISR minimaliste, thread `midi_clk`, `midi_set_bpm()`, `midi_clock_{{start,stop}}`, `midi_get_bpm()`.

**Constantes** :

```c
#define MIDI_EP_OUT  1U
#define MIDI_EP_IN   2U
#define MIDI_EP_SIZE 64U
typedef enum {{ MIDI_DEST_NONE, MIDI_DEST_UART, MIDI_DEST_USB, MIDI_DEST_BOTH }} midi_dest_t;

Hypoth√®ses config :

Toujours afficher les d√©tails

// halconf.h
#define HAL_USE_USB  TRUE
#define HAL_USE_GPT  TRUE

// mcuconf.h
#define STM32_USB_USE_OTG1        TRUE
#define STM32_SERIAL_USE_USART2   TRUE   // PA2 TX, PA3 RX
#define STM32_GPT_USE_TIM3        TRUE

D√©tails d‚Äôimpl√©mentation (cl√©s)
(1) USB ‚Äî √©mission

    send_usb() construit packet[4] :

        packet[0] = (cable<<4) | CIN ; packet[1..3] = status / data (z√©ro‚Äëpad si <3).

    Realtime :

        0xF8 : flush direct si possible ; sinon drop + s_f8_credit++ (borne) ‚Üí burst au prochain flush.

        FA/FB/FC/FE/FF : micro‚Äëtimeout (200 ¬µs par d√©faut) pour obtenir tx_sem. √Ä d√©faut ‚Üí mailbox non bloquante (FA/FB/FC forc√©es en drop‚Äëoldest local).

    Non‚Äërealtime : mailbox ‚Üí thread TX ‚Üí flush ‚â§ 1 ms (plein 64 ou timeout).

(2) USB ‚Äî endpoints & √©v√©nements

    USB_EVENT_CONFIGURED : init EP1 OUT + EP2 IN, armer usbStartReceiveI(EP1 OUT, rx_pkt, 4), primer tx_sem, usb_midi_tx_ready = true.

    USB_EVENT_RESET/UNCONFIGURED/SUSPEND : usb_midi_tx_ready = false (√©vite tout envoi).

    ep2_in_cb() : palToggleLine(LED4) + chBSemSignalI(&tx_sem).

(3) GPT 24 PPQN

    Base 1 MHz ; ticks = 60e6 / (BPM * 24) ; borne 1..65535 (TIM3 16 bits).

    ISR : chBSemSignalI(&clk_sem) seulement.

    Thread midi_clk : chBSemWait() ‚Üí toggle LED1 ‚Üí midi_clock(BOTH).

Garanties temps‚Äër√©el / S√©curit√©

    Jamais de blocage si l‚ÄôUSB tombe ou si l‚ÄôEP est occup√©.

    Clock prioritaire : F8 peut √™tre dropp√©e (puis rattrap√©e par burst), jamais bloquante.

    Transport prioritaire : FA/FB/FC privil√©gient le flush direct (micro‚Äëtimeout), sinon mailbox avec drop‚Äëoldest local (garantie de livraison).

Instrumentation & Statistiques

Structure midi_tx_stats_t (globale) :

    tx_sent_immediate, tx_sent_batched,

    rt_f8_drops, rt_f8_burst_sent,

    rt_other_enq_fallback,

    tx_mb_drops,

    usb_not_ready_drops.

Fonction midi_stats_reset() pour remise √† z√©ro. Possibilit√© de chprintf p√©riodique (UART debug) ou lecture en debugger.
Sc√©narios de test rapide

    Clock seule : MIDI‚ÄëOX ‚Üí TIMING CLOCK (F8) √† 24 PPQN (48/s @120 BPM). LED1/3 tr√®s actives.

    Transport sous charge : flood de notes/CC + midi_start() ‚Üí FA visible quasi imm√©diat ; si EP occup√©, rt_other_enq_fallback++.

    USB d√©branch√© : pas de deadlock ; DIN continue ; usb_not_ready_drops++.

    Rattrapage : sous surcharge, observer de petits paquets de F8 (burst) c√¥t√© host ; rt_f8_burst_sent++.

Limitations restantes

    RX non impl√©ment√©e (USB OUT + DIN IN avec running status + realtime interleav√©).

    SysEx non impl√©ment√© (CIN 0x4/0x5/0x6/0x7).

    Multi‚Äëc√¢bles USB non impl√©ment√©s.

    Pas encore de thread debug UART inclus par d√©faut (optionnel).

Roadmap IMM√âDIATE

    R√©ception MIDI :

        USB OUT (EP1) : parse paquets 4 octets selon CIN ‚Üí mailbox RX ‚Üí callback appli.

        DIN IN (UART2) : parser running status + realtime interleav√© ; filtrage Active Sensing.

    Options pro : Multi‚Äëc√¢bles USB, SysEx chunk√©, device composite CDC+MIDI, router Ksoloti‚Äëlike.

    Clock : option limite 1 burst max par trame USB ; param√©trage dynamique des macros (MIDI_RT_MICROWAIT_US, MIDI_F8_BURST_LIMIT).

    Diagnostics : thread chprintf (UART debug) pour midi_tx_stats + commande shell pour reset/print.

Donn√©es hardware (rappel)

STM32F429ZI (Nucleo‚Äë144) ‚Äî USB OTG FS (USBD1, device forc√©), UART2 PA2/PA3, LEDs : PG10/PG9/PD7/PD6.
EP OUT=1 (64), IN=2 (64).
Mailbox TX=64 msg (4 octets).
Flush TX : batch 64 ou timeout 1 ms (sauf realtime : flush imm√©diat avec coalescence/micro‚Äëtimeout).
"""

readme_text = f"""# STM32F429 USB‚ÄëMIDI Sequencer ‚Äî ChibiOS 21.11.x (√âtape 5)

    Mise √† jour {now}. Cette version int√®gre : mailbox non bloquante, coalescence Clock F8, micro‚Äëtimeout Start/Stop/Continue, garde USB (usb_midi_tx_ready) et compteurs de stats.

1) Aper√ßu

    USB MIDI device stable, r√©‚Äë√©num√©ration au boot, mode device forc√© (NOVBUSSENS).

    API MIDI : Note On/Off, CC, Pitchbend, Start/Stop/Continue/Clock ; destination : USB, DIN, BOTH.

    USB TX non bloquant (voie normale) : mailbox ‚Üí thread TX ‚Üí flush ‚â§ 1 ms (plein 64 ou timeout), tx_sem prim√© √† la config USB.

    Realtime prioritaire :

        F8 : flush imm√©diat si possible ; sinon drop + cr√©dit ‚Üí burst de rattrapage (jusqu‚Äô√† 4 F8 suppl√©mentaires) au prochain flush.

        FA/FB/FC/FE/FF : micro‚Äëtimeout (200 ¬µs) pour obtenir l‚ÄôEP ; sinon fallback mailbox non bloquant (FA/FB/FC en drop‚Äëoldest local).

    DIN OUT (UART2) en parall√®le.

    Clock 24 PPQN hardware (GPT TIM3 @ 1 MHz) + midi_set_bpm() dynamique.

    Valid√© : Ableton re√ßoit clock + notes ; comportement confirm√© avec MIDI‚ÄëOX.

2) Mat√©riel & Pinout

    Carte : Nucleo‚Äë144 STM32F429ZI

    USB : OTG FS (USBD1)

    DIN MIDI OUT : UART2 (SD2) ‚Äî PA2 TX, PA3 RX

    LEDs : PG10 (LED1), PG9 (LED2), PD7 (LED3), PD6 (LED4)

3) Arborescence

    main.c : init syst√®me + USB + smoke test non bloquant + horloge GPT + thread d√©mo.

    usbcfg.c/.h : descripteurs USB‚ÄëMIDI, endpoints, callbacks, √©v√©nements, usb_midi_tx_ready.

    midi.c/.h : API MIDI + mailbox non bloquante + thread TX + coalescence F8 + micro‚Äëtimeout FA/FB/FC + voie DIN + stats.

    midi_clock.c/.h : GPT TIM3 1 MHz, ISR l√©g√®re, thread clock, midi_set_bpm().

4) Configuration ChibiOS

halconf.h

Toujours afficher les d√©tails

#define HAL_USE_USB  TRUE
#define HAL_USE_GPT  TRUE

mcuconf.h

Toujours afficher les d√©tails

#define STM32_USB_USE_OTG1        TRUE
#define STM32_SERIAL_USE_USART2   TRUE   /* SD2 (PA2/PA3) */
#define STM32_GPT_USE_TIM3        TRUE

S√©quence USB au boot (main.c) :

Toujours afficher les d√©tails

usbDisconnectBus(&USBD1);
chThdSleepMilliseconds(1000);
usbStart(&USBD1, &usbcfg);
USBD1.otg->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
USBD1.otg->GCCFG &= ~(USB_OTG_GCCFG_VBUSBSEN | USB_OTG_GCCFG_VBUSASEN);
usbConnectBus(&USBD1);

5) USB‚ÄëMIDI : descripteurs & endpoints

    IF0 : AudioControl ; IF1 : MIDIStreaming.

    EP1 OUT Bulk 64 ; EP2 IN Bulk 64.

    USB_EVENT_CONFIGURED : init EPs + armer RX (usbStartReceiveI(EP1, rx, 4)) + primer tx_sem + usb_midi_tx_ready = true.

    ep2_in_cb() : chBSemSignalI(&tx_sem) (ACK ‚Üí LED4).

    Format paquet USB‚ÄëMIDI 4 octets : [CABLE<<4|CIN, b0, b1, b2] ; CIN : NoteOff=0x8, NoteOn=0x9, CC=0xB, PB=0xE, Realtime=0xF ; Realtime z√©ro‚Äëpad.

6) API MIDI publique

Toujours afficher les d√©tails

typedef enum { MIDI_DEST_NONE, MIDI_DEST_UART, MIDI_DEST_USB, MIDI_DEST_BOTH } midi_dest_t;

void midi_init(void);

void midi_note_on(midi_dest_t d, uint8_t ch, uint8_t note, uint8_t vel);
void midi_note_off(midi_dest_t d, uint8_t ch, uint8_t note, uint8_t vel);
void midi_cc(midi_dest_t d, uint8_t ch, uint8_t cc, uint8_t val);
void midi_pitchbend(midi_dest_t d, uint8_t ch, int16_t value14b);

void midi_start(midi_dest_t d);
void midi_stop(midi_dest_t d);
void midi_continue(midi_dest_t d);
void midi_clock(midi_dest_t d);

7) Chemin des donn√©es (√©mission)
Voie USB

    Realtime F8 ‚Üí flush imm√©diat si possible ; sinon drop + cr√©dit ; prochain flush imm√©diat enverra F8 + burst (‚â§4) dans la m√™me transaction.

    Realtime FA/FB/FC/FE/FF ‚Üí micro‚Äëtimeout (200 ¬µs) pour saisir tx_sem ; sinon mailbox non bloquante (FA/FB/FC drop‚Äëoldest local).

    Autres ‚Üí mailbox ‚Üí thread TX ‚Üí flush ‚â§ 1 ms (plein 64 ou timeout).

Voie DIN

    sdWrite(&SD2, msg, len) en parall√®le et en temps r√©el.

8) Horloge 24 PPQN (GPT)

    TIM3 (GPTD3) √† 1 MHz (r√©solution 1 ¬µs).

    Tick = 60 / (BPM * 24) s ‚Üí ticks = 1e6 * tick, born√© 1..65535.

    ISR : chBSemSignalI(&clk_sem) uniquement.

    Thread midi_clk (prio NORMALPRIO+1) : chBSemWait() ‚Üí LED1 toggle ‚Üí midi_clock(MIDI_DEST_BOTH).

    midi_set_bpm(float) : recalcule la p√©riode et red√©marre le GPT si en marche.

9) LEDs de debug

    LED1 PG10 : tick 24 PPQN (tr√®s rapide).

    LED2 PG9 : enqueue mailbox USB.

    LED3 PD7 : d√©part transfert USB (flush imm√©diat/batch).

    LED4 PD6 : ACK host (fin transfert).

10) Param√®tres de tuning (macros)

Toujours afficher les d√©tails

// Mailbox pleine: 0 = drop nouveau (d√©faut), 1 = drop ancien + reposte
#define MIDI_MB_DROP_OLDEST    0

// Micro-attente (¬µs) pour Start/Stop/Continue avant fallback mailbox
#define MIDI_RT_MICROWAIT_US   200

// Rattrapage F8: nombre de clocks suppl√©mentaires envoy√©es d‚Äôun coup
#define MIDI_F8_BURST_LIMIT    4

11) Statistiques runtime

midi_tx_stats_t :

    tx_sent_immediate, tx_sent_batched

    rt_f8_drops, rt_f8_burst_sent

    rt_other_enq_fallback, tx_mb_drops, usb_not_ready_drops

midi_stats_reset() pour tout remettre √† z√©ro.
Option : thread chprintf (UART) pour afficher chaque seconde.
12) Build & Test

    V√©rifier halconf.h / mcuconf.h (USB, GPT, USART2).

    Flasher.

    Windows : ouvrir MIDI‚ÄëOX ‚Üí Options ‚Üí MIDI Devices‚Ä¶ ‚Üí s√©lectionner le device en Input ‚Üí View ‚Üí Input Monitor.

    Attendus :

        clock F8 r√©guli√®re (48/s @120 BPM),

        FA/FC visibles sous charge,

        LED1/3 tr√®s actives, LED4 pulse √† chaque ACK.

13) Diagnostics rapides

    LED1 OK, LED2/3/4 muettes ‚Üí probl√®me voie USB (init/prime/toggle).

    LED2 OK, LED3 muette ‚Üí thread TX ne flushe pas (s√©maphore jamais lib√©r√©).

    LED3 OK, LED4 muette ‚Üí host ne r√©pond pas / EP IN mal initialis√©.

    Pas de clock dans DAW ‚Üí v√©rifier z√©ro‚Äëpad realtime + flush imm√©diat actif + usb_midi_tx_ready.

14) Limitations

    Pas encore de r√©ception USB/DIN (parsing CIN / running status).

    SysEx non g√©r√©.

    Multi‚Äëc√¢bles non g√©r√©s.

15) Roadmap

    R√©ception MIDI : EP1 OUT (USB) + UART2 RX (running status + realtime interleav√©).

    Options pro : multi‚Äëc√¢bles, SysEx chunk√©, CDC+MIDI composite, router Ksoloti‚Äëlike.

    Clock : option limiter √† 1 burst F8 par trame ; macros runtime.

    Debug : thread UART + commandes shell pour stats.
    
---

## ‚úÖ Bring-up OLED + ADC + M√©tronome (mise √† jour : 26/09/2025)

### √âcran (SSD1309 SPI) ‚Äî √©tat actuel

* **Driver minimal maison** pour SSD1309 128√ó64, SPI1 en **mode 0**, lignes: **SCK=PA5, MOSI=PA7, CS=PB4, DC=PB5**, RESET optionnelle sur PB8 (d√©sactivable c√¥t√© board). La config SPI active un **baudrate ‚âà APB2/8** (sur F429, ~10,5 MHz par d√©faut), via `SPIConfig` ‚Üí `.cr1 = SPI_CR1_BR_2`. Le flux est command/data via DC et `spiSelect/Unselect` sur **SPID1**. 
* **Init SSD1309** : OFF, clock divide, mux=0x3F (64 lignes), offset=0, start line, charge pump, **page addressing (0x20,0x02)**, orientation **A1/C8** (miroir H/V), COM pins=0x12, contraste=0x7F, precharge=0xF1, Vcomh=0x40, full display ON. Correction d‚Äôadresse colonnes **0x00‚Äì0x7F** puis ON. Clear framebuffer (1024 octets), pr√™t √† dessiner. 
* **Framebuffer + primitives** :

  * `display_clear()`, `display_update()` (envoi page par page: `0xB0 + page`, `0x00/0x10`, plage colonnes 0x00‚Äì0x7F). 
  * Texte 5√ó7 (ASCII 32‚Äì126) via `display_draw_text()`, caract√®re via `display_draw_char()`, et entiers via `display_draw_number()` (s‚Äôappuie sur `chsnprintf`). Police **externalis√©e** `font5x7.h`. 
* **Thread d‚Äôaffichage d√©di√©** : `display_start()` cr√©e un thread qui pousse le framebuffer ~**30 FPS** (`display_update()` + `sleep 33 ms`). √áa d√©corr√®le l‚ÄôUI de l‚Äôacquisition pots. 

### Pots (4 √ó potentiom√®tres sur PC0..PC3) ‚Äî √©tat actuel

* **ADC multi-canaux en DMA circulaire**, groupe de **4 canaux** (IN10..IN13), **profondeur 8** pour un moyennage logiciel simple. Un thread `PotReader` calcule toutes les **20 ms** la moyenne des 8 √©chantillons pour chaque pot et met √† jour un cache `pot_values[4]`. Acc√®s lecture via `pots_get(index)` (valeurs **0..4095**). 
* **API** :

  * `void pots_start(void);` ‚Äî d√©marre ADC1 en conversion circulaire + thread de lecture.
  * `int  pots_get(int index);` ‚Äî lit la valeur moyenne filtr√©e (0..4095).
  * `#define NUM_POTS 4` ‚Äî mapping actuel **PC0, PC1, PC2, PC3**. 

### M√©tronome (bpm pilot√© par pot) ‚Äî √©tat actuel

* Thread `Metronome` autonome : calcule **BPM = 60 + (pot3 * 180 / 4095)**, donc plage ~**60‚Äì240 BPM**, et dort `period_ms = 60000/BPM`. (TODO dans ce thread : blink LED / produire une vraie clock MIDI/Timer). 
* D√©marrage via `metronome_start()` (header minimal `metronome.h`). 

### Boucle `main` de debug ‚Äî √©tat actuel

* **Initialisation** : HAL/RT, `display_init()` puis **`display_start()`** (rafra√Æchissement auto), **`pots_start()`** (ADC DMA + thread), **`metronome_start()`**. 
* **Rendu debug** √† l‚Äô√©cran (30 FPS) :

  * Ligne ‚ÄúPots:‚Äù + **affichage des 4 valeurs** (0..4095) sous forme num√©rique (une ligne par pot).
  * **BPM calcul√©** (d‚Äôapr√®s pot 3) affich√© √† droite (‚ÄúBPM: xxx‚Äù).
  * La boucle UI dort **33 ms** (~30 FPS), l‚Äô√©cran est fluide, l‚Äôacquisition pots est ind√©pendante (thread s√©par√©). 

### Interface publique ajout√©e (r√©capitulatif headers)

* **display.h** :
  `display_init()`, `display_clear()`, `display_update()`, `display_draw_text()`, `display_draw_char()`, `display_draw_number()`, `display_get_buffer()`, **`display_start()`**. 
* **pots.h** :
  `pots_start()`, `pots_get(int)`, `NUM_POTS`. 
* **metronome.h** :
  `metronome_start()`. 

### Notes pratiques / comportements observ√©s

* **OLED** : le sens d‚Äôaffichage a √©t√© fix√© via **A1/C8** (miroirs), et l‚Äôadressage **page** garantit un envoi lin√©aire du framebuffer. Les tests initiaux ¬´ plein √©cran ¬ª puis texte ont confirm√© la bonne init; des bandes observ√©es au d√©but ont √©t√© corrig√©es par la **plage colonnes 0x00‚Äì0x7F** et la font 5√ó7 propre. 
* **R√©activit√© UI** : la perception de lag provenait de la **moyenne sur 8 √©chantillons** + **p√©riode 20 ms** du thread pots ; l‚Äôusage d‚Äôun thread d‚Äôaffichage d√©di√© √©vite de coupler affichage et acquisition (l‚Äô√©cran rafra√Æchit ind√©pendamment √† ~30 FPS). 
* **BPM en temps r√©el** : la valeur affich√©e en haut √† droite √©volue en continu avec **pot3** (PC3), conforme au mapping actuel et √† la formule du thread M√©tronome. 

---



## Boutons (SN74HC165 √ó5 en cascade) ‚Äî bring-up, API et √©tat exact (26/09/2025)

### Mat√©riel & pins (confirm√© sur board)

* **74HC165 x5** en cascade ‚Üí **40 entr√©es** lues en s√©rie.
* **Lignes STM32** :

  * `SR_LOAD` (PL / SH/LD) ‚Üí **PB0** (sortie push-pull, niveau repos HIGH).
  * `SR_CLK`  (CP)         ‚Üí **PB1** (sortie push-pull, repos LOW).
  * `SR_DATA` (QH)         ‚Üí **PG11** (entr√©e **pull-up**).
* **Attention logique** : les entr√©es des 165 sont **actives bas** (bouton press√© ‚áí 0 sur QH) ‚Üí le firmware **inverse** la lecture.

### Module fichiers

* `buttons.h`

  ```c
  #define NUM_BUTTONS 40

  typedef enum { BUTTON_EVENT_PRESS = 0, BUTTON_EVENT_RELEASE } button_event_type_t;

  typedef struct {
      int id;
      button_event_type_t type;
  } button_event_t;

  void buttons_start(void);
  bool button_is_pressed(int id);
  bool buttons_poll(button_event_t *evt, systime_t timeout);
  ```
* `buttons.c` (impl√©mentation)

  * **Thread** `Buttons` (prio `NORMALPRIO`) qui :

    1. **latch** : `palClear(PB0)` ‚Üí 1 ¬µs ‚Üí `palSet(PB0)`
    2. **scan 40 bits** : pour i=0..39

       * lit `SR_DATA` (PG11), **inverse** (`!palReadLine`) ‚Üí `button_states[i]`
       * **pulse** clock : `PB1=HIGH` ‚Üí 1 ¬µs ‚Üí `PB1=LOW`
    3. compare `button_states[i]` vs `last_states[i]` ‚Üí si changement, **poste un event** (`PRESS`/`RELEASE`) dans une **mailbox**.
    4. dort **5 ms** (anti-rebonds l√©ger + charge CPU faible).
  * **Mailbox** : `mailbox_t evt_mb; msg_t evt_queue[16];`

    * **ChibiOS 21.11.x** ‚áí on utilise **`chMBPostTimeout()`** / **`chMBFetchTimeout()`** (pas `chMBPost/chMBFetch`).
    * Event pack√© dans un `msg_t` : `msg = id | (type<<8)` ; d√©pack dans `buttons_poll()`.
  * **API** :

    * `button_is_pressed(id)` : acc√®s direct au cache (binaire, sans locker, lecture imm√©diate).
    * `buttons_poll(evt, timeout)` : non bloquant si `timeout = TIME_IMMEDIATE`.

> D√©cision cl√© : on **garde une lecture ‚Äúsimple‚Äù index√©e (i=0..39)** et on **inverse au fil de l‚Äôeau**, car c‚Äôest ce qui garantit l‚Äôalignement exact des indices avec ton c√¢blage. Les essais de packing `uint64_t` + MSB/LSB avaient introduit des d√©calages.

### Mapping **observ√© sur hardware** (IDs r√©els)

```
Boutons sp√©ciaux :
  REGLAGE = 37
  SHIFT   = 36
  +       = 39
  -       = 38
  REC     = 11
  PLAY    = 9
  STOP    = 10

Pages :
  PAGE1 = 35
  PAGE2 = 34
  PAGE3 = 33
  PAGE4 = 32
  PAGE5 = 12

Param menus (BM1..BM8) :
  PARAM1 = 5
  PARAM2 = 4
  PARAM3 = 3
  PARAM4 = 2
  PARAM5 = 6
  PARAM6 = 7
  PARAM7 = 0
  PARAM8 = 1

S√©quenceur (BS1..BS16) :
  SEQ1  = 29
  SEQ2  = 28
  SEQ3  = 27
  SEQ4  = 26
  SEQ5  = 21
  SEQ6  = 20
  SEQ7  = 19
  SEQ8  = 18
  SEQ9  = 30
  SEQ10 = 31
  SEQ11 = 24
  SEQ12 = 25
  SEQ13 = 22
  SEQ14 = 23
  SEQ15 = 16
  SEQ16 = 17
```

* Fichier **`buttons_map.h`** expose ces IDs en macros lisibles :

  ```c
  #define BTN_REGLAGE 37
  #define BTN_SHIFT   36
  #define BTN_PLUS    39
  #define BTN_MINUS   38
  #define BTN_REC     11
  #define BTN_PLAY    9
  #define BTN_STOP    10
  #define BTN_PAGE1   35
  #define BTN_PAGE2   34
  #define BTN_PAGE3   33
  #define BTN_PAGE4   32
  #define BTN_PAGE5   12
  #define BTN_PARAM1  5
  #define BTN_PARAM2  4
  #define BTN_PARAM3  3
  #define BTN_PARAM4  2
  #define BTN_PARAM5  6
  #define BTN_PARAM6  7
  #define BTN_PARAM7  0
  #define BTN_PARAM8  1
  #define BTN_SEQ1    29
  #define BTN_SEQ2    28
  #define BTN_SEQ3    27
  #define BTN_SEQ4    26
  #define BTN_SEQ5    21
  #define BTN_SEQ6    20
  #define BTN_SEQ7    19
  #define BTN_SEQ8    18
  #define BTN_SEQ9    30
  #define BTN_SEQ10   31
  #define BTN_SEQ11   24
  #define BTN_SEQ12   25
  #define BTN_SEQ13   22
  #define BTN_SEQ14   23
  #define BTN_SEQ15   16
  #define BTN_SEQ16   17
  ```

### Comportement vis√© (conforme √† la vision Elektron-like)

* **Logique binaire** c√¥t√© driver (pas de double-tap / long-press au niveau bas) :

  * le module fournit **`PRESS`/`RELEASE`** + l‚Äô√©tat binaire instantan√© (`button_is_pressed()`),
  * toute la **s√©mantique UI** (Shift actif, cyclage de menus, modes custom, copier/clear/record‚Ä¶) se fait **au dessus** (UI/Sequencer).
* **Raisons** :

  * simplifie le driver,
  * √©vite de figer une ergonomie,
  * rend l‚ÄôUI libre de d√©finir ses propres timings (double-tap, hold, repeat) par **mesure de temps** entre deux `PRESS` si n√©cessaire.

### Tests & debug r√©alis√©s

* **Affichage OLED** : rendu ‚ÄúPots + BPM‚Äù + derni√®re touche appuy√©e.
* Mode **diagnostic** (temporaire) : affichage de toutes les touches **press√©es en temps r√©el** en scannant `button_is_pressed(i)`.
* **Probl√®mes rencontr√©s & fixes** (chronologie) :

  1. **Bouton ‚Äú38‚Äù toujours actif** ‚áí cause : pas de pull-up / inversion manquante.

     * **Fix** : `SR_DATA` en **`PAL_MODE_INPUT_PULLUP`** + **`!palReadLine()`**.
  2. **Un seul bit varie / indices qui bougent** ‚áí cause : erreur d‚Äôordre **MSB/LSB** lors de l‚Äôassemblage 64 bits.

     * **Fix** : abandon du packing fragile, retour √† la **lecture index√©e i=0..39** (fiable) ou lecture invers√©e correctement test√©e.
  3. **Liens (‚Äúundefined reference‚Äù) sur mailbox** ‚áí `chMBPost/chMBFetch` non pr√©sents en **ChibiOS 21.11**.

     * **Fix** : utiliser **`chMBPostTimeout`** / **`chMBFetchTimeout`**.
  4. **Lenteur per√ßue** (events uniquement) ‚áí l‚ÄôUI rafra√Æchissait toutes les 50 ms et ne lisait que les transitions.

     * **Fix** : UI √† 20‚Äì33 ms pour l‚Äôaffichage + acc√®s direct `button_is_pressed()` quand on veut du ‚Äúcontinu‚Äù.

### Param√®tres, perfs & contraintes

* **P√©riode de scan** : 5 ms (d√©faut).
* **Anti-rebonds** : ‚Äúnaturel‚Äù par la p√©riode ; si besoin, on pourra ignorer un changement si < 10 ms (non n√©cessaire pour l‚Äôinstant).
* **CPU** : n√©gligeable (40 lectures GPIO + 40 pulses clock / 5 ms).
* **RT-safety** : aucune attente bloquante ; mailbox non bloquante (timeout imm√©diat).
* **√âcran** : thread s√©par√© (‚âà30 FPS) pour ne pas coupler affichage et scan boutons.

### Int√©gration actuelle (UI de debug)

* `UIThread` affiche :

  * 4 pots (`pots_get()`),
  * BPM calcul√© (pot 4),
  * dernier bouton appuy√© via `buttons_poll()` **ou** liste des boutons actuellement press√©s via `button_is_pressed()`.
* **D√©couplage** confirm√© : l‚Äôaffichage reste fluide m√™me si on spamme les boutons.

### Ce qui reste √† faire (c√¥t√© UI/ergonomie, **au-dessus** du driver)

* **Gestion Shift** : `if (button_is_pressed(BTN_SHIFT)) ‚Ä¶` pour commuter les fonctions **pages/menus/modes**.
* **Cyclage BM** : compter les `PRESS` successifs d‚Äôun `BTN_PARAMx` pour tourner sur les sous-menus (selon la cartouche).
* **Modes custom (Pattern/Keyboard/Sequencer/Random)** :

  * d√©clench√©s par `SHIFT + BSx`,
  * param UI au **double-tap** (√† faire au niveau UI en mesurant Œît entre deux `PRESS` du m√™me bouton).
* **Transport Elektron-like** : interpr√©tation combos `REC/PLAY/STOP + SHIFT` (copy/clear/live rec/TR-style), **toujours** au niveau UI.

---

**R√©sum√©** :

* Driver **boutons stable** (lecture 5√ó74HC165 avec inversion active-bas, mapping r√©el document√©, mailbox d‚Äô√©v√©nements pr√™te).
* **Aucun comportement d‚Äôergonomie fig√©** dans le driver : tout se d√©cide dans l‚ÄôUI ‚Üí parfaitement align√© avec ta vision ‚ÄúElektron-like‚Äù et l‚Äôapproche modulaire.
* La base est **propre et maintenable** pour brancher ensuite l‚Äô√©tat UI, le s√©quenceur, le MIDI et l‚Äôaffichage avanc√© (pages & vues custom).


---

## LEDs adressables (WS2812 / SK6812) ‚Äî bring-up, driver ASM et API logique (27/09/2025)

### Mat√©riel & pins (confirm√© sur board)

* **Cha√Æne de 17 LEDs adressables** (WS2812B ou √©quivalent, datasheet C5378731 confirm√©e).
* **Ligne DATA** ‚Üí **PD3** via un **level shifter 3.3V ‚Üí 5V**.
* L‚Äôordre physique est document√© et mapp√© sur les boutons :

  * **LED0** = bouton REC,
  * **LED1..LED8** = boutons SEQ8..SEQ1 (dans cet ordre),
  * **LED9..LED16** = boutons SEQ9..SEQ16.

### Driver bas niveau

* Fichiers : `adress_leds.c` / `adress_leds.h`.
* Impl√©mentation **bit-banging optimis√©e en assembleur** (inline ASM ARMv7-M) calibr√©e pour **168 MHz** :

  * `send_bit_asm()` ‚Üí g√©n√®re le timing **T0H ‚âà 0.35¬µs / T0L ‚âà 0.9¬µs / T1H ‚âà 0.7¬µs / T1L ‚âà 0.6¬µs**.
  * Boucles `.rept` calibr√©es avec `nop`.
  * Usage direct du registre **BSRR** pour pousser HIGH/LOW sans latence.
  * Stable et reproductible, **ind√©pendant du reste du code** (pas de perturbation quand on ajoute d‚Äôautres modules).
* API bas niveau :

  ```c
  void adress_leds_init(void);
  void adress_leds_update(void);
  void adress_leds_set(int index, uint8_t r, uint8_t g, uint8_t b);
  void adress_leds_set_color(int index, led_color_t color);
  void adress_leds_clear(void);
  ```
* Donn√©es stock√©es dans un buffer `led_buffer[NUM_ADRESS_LEDS]` puis transmises d‚Äôun coup avec `adress_leds_update()`.
* **Reset time** respect√© : `chThdSleepMicroseconds(300)` apr√®s flush.

### Couleurs pr√©d√©finies & mapping

* `led_color_t` (GRB, comme WS2812/SK6812).
* Palette de couleurs pr√™tes √† l‚Äôemploi :

  * `COLOR_RED`, `COLOR_GREEN`, `COLOR_BLUE`, `COLOR_YELLOW`, `COLOR_CYAN`, `COLOR_MAGENTA`, `COLOR_WHITE`,
  * extras : `COLOR_ORANGE`, `COLOR_PINK`, `COLOR_PURPLE`, `COLOR_TURQUOISE`, `COLOR_OFF`.
* **Mapping boutons ‚Üî LEDs** d√©fini par macros (`LED_REC`, `LED_SEQ1`..`LED_SEQ16`) directement dans `adress_leds.h`.

### API logique (Elektron-like)

* Extension haut niveau pour g√©rer des **modes d‚Äôaffichage** (fixe, blink, playhead).
* Types :

  ```c
  typedef enum {
      LED_MODE_OFF,
      LED_MODE_ON,
      LED_MODE_BLINK,
      LED_MODE_PLAYHEAD
  } led_mode_t;

  typedef struct {
      led_color_t color;
      led_mode_t mode;
  } led_state_t;

  extern led_state_t leds[NUM_ADRESS_LEDS];
  ```
* Fonctions :

  ```c
  void leds_set(int index, led_color_t color, led_mode_t mode);
  void leds_render(void);
  ```
* `leds_set()` d√©finit l‚Äô√©tat logique d‚Äôune LED (couleur + mode).
* `leds_render()` applique ces √©tats :

  * **ON** : couleur fixe,
  * **OFF** : LED √©teinte,
  * **BLINK** : clignote ~2 Hz (toggle toutes les 500 ms),
  * **PLAYHEAD** : effet puls√©/rapide (~40 Hz).
* Rendu rafra√Æchi par un thread (p√©riode 25 ms) ‚Üí animations fluides et d√©coupl√©es de la logique s√©quenceur.

### Tests r√©alis√©s

* **Main test** :

  * SEQ1 = vert fixe (`LED_MODE_ON`),
  * SEQ5 = jaune clignotant (`LED_MODE_BLINK`),
  * REC = rouge clignotant (`LED_MODE_BLINK`).
    ‚Üí Fonctionne parfaitement sur hardware.
* V√©rifi√© : ajout d‚Äôautres modules (USB, boutons, ADC, √©cran) **n‚Äôaffecte pas le timing** ‚Üí les LEDs restent stables.

### Int√©gration future (s√©quenceur Elektron-like)

* Le **s√©quenceur** (BPM, steps, playhead, notes actives) pilotera les LEDs via `leds_set()`.
* Exemples pr√©vus :

  * **Playhead** ‚Üí avance sur SEQ1..SEQ16 (`LED_MODE_PLAYHEAD`).
  * **Step actif** ‚Üí couleur fixe (ex : vert si note pr√©sente).
  * **REC** ‚Üí rouge blink si en enregistrement.
  * **Pattern mode** ‚Üí toutes les LEDs SEQ allum√©es en jaune, active en bleu.
* La logique BPM/notes reste dans le **module S√©quenceur**, le module LEDs ne fait que **rendre l‚Äô√©tat visuel**.

---


## Encodeurs (TIM HW + soft IRQ via EXT) ‚Äî bring-up et √©tat exact (27/09/2025)

### Contexte

* Carte STM32F429ZI + ChibiOS **21.11.x**.
* Encodeurs mat√©riels : reli√©s directement √† des timers en mode quadrature.
* Encodeur logiciel (ENC3) : pas de timer d√©di√© ‚Üí d√©codage quadrature **logiciel** via interruptions GPIO (driver **EXT**, pas EXTI).

### √âtat initial

* **ENC1 (TIM8 PC6/PC7)**, **ENC2 (TIM4 PB6/PB7)**, **ENC4 (TIM2 PA15/PB3)** fonctionnels avec configuration directe des registres (SMCR=EncoderMode3, CC1S/CC2S, ARR=0xFFFF, CNT=0).
* **ENC3 (PD12/PD13)** : impl√©ment√© en pur polling logiciel ‚Üí tr√®s lent, valeurs 0‚Äì3 seulement, sens de lecture al√©atoire.

### Probl√®mes rencontr√©s

1. **Affichage** : l‚ÄôOLED incr√©mentait parfois les dizaines au lieu des unit√©s ‚Üí cause : rafra√Æchissement coupl√© directement √† l‚Äôacquisition ‚Üí corrig√© en ins√©rant un **thread d‚Äôaffichage d√©di√©** (framerate stable ~30 FPS).
2. **Confusion EXT/EXTI** :

   * Sur ChibiOS 21.11.x, l‚ÄôAPI valide est **EXT** (`extStart`, `EXTConfig`, `EXTDriver`, `EXT_CH_MODE_*`).
   * Les symboles **EXTI** (ex: `EXTI_MODE_BOTH_EDGES`) appartiennent √† la branche ChibiOS-mainline post√©rieure (API renomm√©e). ‚Üí **Erreur de compile** si utilis√©s.
   * Preuve : fichier `os/hal/include/ext.h` (fourni dans 21.11.x) d√©finit bien `EXTDriver`, `EXTConfig`, `EXT_CH_MODE_*`.
3. **Board mapping** :

   * `LINE_ENC3_A = PAL_LINE(GPIOD, 12U)`.
   * `LINE_ENC3_B = PAL_LINE(GPIOD, 13U)`.
   * Donc EXT doit √™tre configur√© **sur les canaux 12 et 13** (port D). ‚Üí Probl√®me initial venait du fait qu‚Äôon utilisait directement `LINE_ENC3_A/B` comme indices, ce qui ne marchait pas.

### Modifications appliqu√©es

Parfait üëç merci pour ton retour. Tu as raison : ton README est **extr√™mement d√©taill√©** (style carnet de bord technique), donc il faut que je garde ce niveau de granularit√©, pas juste une synth√®se.

üëâ Voil√† une version **beaucoup plus d√©taill√©e et pointilleuse**, qui remplace l‚Äôancienne section `test_encoders`. Elle reprend :

* la gen√®se (exp√©rimentation avec `test_encoders`),
* le portage vers un vrai module `encoders`,
* les choix techniques (timers, EXTI, table quadrature),
* les probl√®mes rencontr√©s (EXT vs EXTI, rebonds, latence),
* l‚Äôajout progressif (delta, acc√©l√©ration, macros r√©glables),
* les validations sur √©cran SPI.

---

## Encodeurs

### Historique

Initialement, les encodeurs avaient √©t√© test√©s via un module temporaire **`test_encoders`**.
Ce code servait uniquement de validation de principe :

* lecture brute des timers mat√©riels (TIM8, TIM4, TIM2),
* d√©codage logiciel rudimentaire pour l‚Äôencodeur 3 (PD12/PD13),
* affichage des valeurs sur √©cran SPI pour valider le c√¢blage.

Ce module a permis de confirmer le **fonctionnement √©lectrique et logiciel de base** des 4 encodeurs, mais il √©tait monolithique, peu r√©utilisable, et sans abstraction claire.

√Ä partir de l√†, il a √©t√© enti√®rement r√©√©crit sous forme de **module d√©di√© `encoders`**, propre, modulable et extensible, destin√© √† s‚Äôint√©grer dans le firmware final.

---

### Architecture mat√©rielle

* **ENC1 (PC6/PC7)** ‚Üí d√©codage mat√©riel par **TIM8** en mode quadrature.
* **ENC2 (PB6/PB7)** ‚Üí d√©codage mat√©riel par **TIM4** en mode quadrature.
* **ENC4 (PA15/PB3)** ‚Üí d√©codage mat√©riel par **TIM2** en mode quadrature.
* **ENC3 (PD12/PD13)** ‚Üí **pas reli√© √† un timer mat√©riel** ‚Üí impl√©mentation par d√©codage logiciel via interruptions EXTI.

Tous les timers sont configur√©s en **mode encodeur quadrature X4**.
Le comptage est ensuite **divis√© par 4 en lecture** afin d‚Äôexposer √† l‚ÄôAPI un comptage en **X1 logique** (1 tick = 1 cran m√©canique), garantissant l‚Äôuniformit√© entre les encodeurs mat√©riels et l‚Äôencodeur logiciel.

---

### D√©codage logiciel (ENC3)

ENC3 est particulier : il n‚Äôest pas c√¢bl√© sur un timer mat√©riel.
Il est donc g√©r√© int√©gralement en **logiciel** via deux interruptions PAL/EXTI sur PD12 et PD13.

* Les lignes A et B d√©clenchent des IRQ sur **les deux fronts (rising/falling)**.
* Chaque changement d‚Äô√©tat (A,B) est m√©moris√© et compar√© √† l‚Äô√©tat pr√©c√©dent.
* Une **table de transitions quadrature (16 entr√©es)** est utilis√©e pour d√©terminer +1, -1 ou 0 √† chaque tick.
* Le r√©sultat est coh√©rent avec les autres encodeurs (m√™me X1 logique).

Ce m√©canisme a remplac√© une tentative initiale d‚Äôutilisation du driver **EXT** de ChibiOS, qui s‚Äôest r√©v√©l√©e inadapt√©e (erreurs de type `EXTDriver` non reconnu). La solution finale s‚Äôappuie donc sur **EXTI via PAL**, plus simple et portable.

---

### API publique

Le module expose une API claire et compacte :

```c
void     encoders_start(void);
int16_t  encoder_get(encoder_id_t id);
void     encoder_reset(encoder_id_t id);
int16_t  encoder_get_delta(encoder_id_t id);
int16_t  encoder_get_delta_accel(encoder_id_t id);
```

* **`encoder_get`** : valeur absolue courante (en ticks X1).
* **`encoder_reset`** : remise √† z√©ro d‚Äôun encodeur.
* **`encoder_get_delta`** : incr√©ment depuis le dernier appel (valeur relative).
* **`encoder_get_delta_accel`** : idem, mais avec **acc√©l√©ration dynamique**.

Les encodeurs sont identifi√©s via l‚Äô√©num√©ration :

```c
typedef enum {
    ENC1 = 0,
    ENC2,
    ENC3,
    ENC4,
    NUM_ENCODERS
} encoder_id_t;
```

---

### Gestion du delta

Un cache interne `last_values[]` conserve la derni√®re valeur lue pour chaque encodeur.
Lorsqu‚Äôon appelle `encoder_get_delta()`, le module :

1. Lit la valeur absolue courante.
2. Soustrait la valeur pr√©c√©dente.
3. Met √† jour le cache.
4. Retourne la diff√©rence (positive ou n√©gative).

Cette logique garantit que **chaque tick est comptabilis√© une seule fois**, quelle que soit la fr√©quence d‚Äôappel.

---

### Acc√©l√©ration (ergonomie Elektron)

Afin de retrouver la **sensation Elektron** (√©dition fine lente, sauts rapides √† grande vitesse), une logique d‚Äôacc√©l√©ration a √©t√© impl√©ment√©e.

Principe :

* On mesure le temps `dt` √©coul√© depuis le dernier tick.
* On calcule une vitesse en ticks/s.
* En fonction de seuils (`LOW_SPEED`, `MID_SPEED`), on applique un **facteur multiplicatif** plus ou moins √©lev√©.
* Le facteur est born√© par `MAX_FACTOR` pour √©viter les d√©bordements.

Macros de configuration dans `encoders.h` :

```c
#define ENC_ACCEL_LOW_SPEED     17.0f
#define ENC_ACCEL_MID_SPEED     18.5f
#define ENC_ACCEL_MID_GAIN       5.5f
#define ENC_ACCEL_BASE           6.5f
#define ENC_ACCEL_HIGH_GAIN     10.0f
#define ENC_ACCEL_MAX_FACTOR   100.0f
```

Ces r√©glages permettent :

* √Ä **vitesse lente**, un incr√©ment = 1 tick (√©dition fine).
* √Ä **vitesse moyenne**, une croissance d√©j√† sensible.
* √Ä **vitesse rapide**, une acc√©l√©ration tr√®s forte (0 ‚Üí 127 en une seule rotation).

L‚Äôalgorithme a √©t√© test√© et valid√© en conditions r√©elles, affichage sur √©cran SPI √† l‚Äôappui.

---

### Gestion des rebonds

Les encodeurs m√©caniques pr√©sentent parfois des **rebonds de contact**, amplifi√©s par l‚Äôacc√©l√©ration.
Un filtrage logiciel simple a √©t√© ajout√© :

```c
#define ENC_DEBOUNCE_MS   15
```

* Tout tick survenant √† moins de 15 ms du pr√©c√©dent est **ignor√©** (consid√©r√© comme rebond).
* Valeur ajustable (2‚Äì5 ms pour encodeurs de qualit√©, 10‚Äì15 ms pour encodeurs plus ¬´ bruyants ¬ª).
* Aucun impact perceptible sur la latence.

Une future am√©lioration mat√©rielle (condensateur RC entre A/GND et B/GND) pourra compl√©ter ce filtrage dans une r√©vision de PCB.

---

### Validation et debug

* Les valeurs absolues, delta et delta acc√©l√©r√© ont √©t√© affich√©es en temps r√©el sur l‚Äô**√©cran SPI**.
* Les variations se comportent comme attendu :

  * incr√©ments progressifs et r√©guliers en rotation lente,
  * acc√©l√©rations exponentielles en rotation rapide,
  * absence de parasites notables gr√¢ce au filtrage 15 ms.

---

### √âtat actuel

* ‚úÖ D√©codage hardware (TIM8/TIM4/TIM2) et software (EXTI sur PD12/PD13) fonctionnels.
* ‚úÖ Normalisation en X1 logique pour coh√©rence.
* ‚úÖ API stable et compacte, utilisable dans tout le firmware.
* ‚úÖ Gestion des deltas relative/absolue.
* ‚úÖ Acc√©l√©ration dynamique inspir√©e Elektron, macros r√©glables.
* ‚úÖ Anti-rebond logiciel optionnel et efficace.
* ‚úÖ Debug et validation terrain via √©cran SPI.

üëâ Le module `encoders` est d√©sormais **mature** et remplace d√©finitivement `test_encoders`. Il est pr√™t √† √™tre int√©gr√© dans les threads **UI** et **Sequencer** du projet principal.

---

## UI / Rendu OLED ‚Äî squelette initial (29/09/2025)

### Objectif

Mettre en place un **renderer g√©n√©rique** permettant d‚Äôafficher les diff√©rents menus Elektron-like sur OLED, avec s√©paration claire :

* **Cartouche (cart name)** en haut,
* **Nom du menu** (et num√©ro de cycle 1/4, 2/4, etc.),
* **Titres de pages** (ligne horizontale),
* **Param√®tres** (label + valeur),
* **Valeurs dynamiques** (pots, BPM, etc.).

### Polices (√©tat actuel)

* **Impl√©mentation unique active** : police 5√ó7 (ASCII 32‚Äì126), tir√©e de `font5x7.h`.
* **API d‚Äôaffichage** :

  * `display_draw_text(x,y,string)` ‚Äî √©crit une cha√Æne,
  * `display_draw_char(x,y,c)` ‚Äî un caract√®re,
  * `display_draw_number(x,y,n)` ‚Äî un entier formatt√©.
* La police courante est cod√©e en dur (5√ó7).
* L‚Äôid√©e (futur) : introduire une **s√©lection de police par zone** :

  * 4√ó6 pour labels/pages/valeurs param,
  * 6√ó10 pour titre cartouche + menu,
  * 5√ó7 pour BPM / bank / pattern.

### Menus & cartouches (premiers tests)

* Ajout d‚Äôun **descripteur de cartouche** `ui_cart_desc_t`, regroupant plusieurs menus.
* Exemple `CART_XVA1` avec 4 menus OSC1 cycl√©s :

  * `OSC1 1/4`, `OSC1 2/4`, `OSC1 3/4`, `OSC1 4/4`.
* Chaque menu contient un tableau `page_titles` (`"Struct"`, `"Timbre"`, `"Env"`, `"Mix"`, `"Mod"`) et des param√®tres organis√©s par pages.
* Param√®tres : support **BOOL**, **ENUM**, **CONT** (range 0‚Äì127).
* Labels `On/Off`, `Wave`, etc. g√©r√©s via `meta.en` ou `meta.range`.

### Logo / √©l√©ments graphiques (pr√©vu)

* Souhait : afficher une **ic√¥ne de note musicale** devant le BPM, inspir√©e du code Lopaka :

  ```c
  u8g2.drawLine(102, 0, 102, 6);
  u8g2.drawXBM(98, 6, 4, 3, image_Layer_26_bits);
  ```

* Non encore port√© dans le driver SSD1309 maison, mais not√© dans la roadmap UI.

### Menus cycl√©s (concept)

* Principe : certains menus ne changent pas de page interne mais **cyclent sur plusieurs menus** avec le m√™me bouton.
* Exemple : appuyer plusieurs fois sur `OSC1` fait tourner `OSC1 1/4` ‚Üí `OSC1 2/4` ‚Üí etc.
* C‚Äôest **ind√©pendant des pages** (les pages sont internes √† un menu).
* La notation `1/4`, `2/4` affich√©e √† c√¥t√© du nom de menu refl√®te ce cyclage.

### Threads impliqu√©s

* **displayThread** : rafra√Æchit l‚ÄôOLED ~30 FPS, ind√©pendant du reste.
* **UIThread (debug)** : appelle le renderer avec `CART_XVA1` ‚Üí dessine la cartouche, le menu et ses param√®tres.

### Limitations actuelles

* Une seule police active (5√ó7).
* Pas encore d‚Äôic√¥ne ou de symboles graphiques (note, barres, etc.).
* Param√®tres affich√©s mais sans interaction directe avec les pots/encodeurs.
* Pas encore de logique ‚ÄúElektron‚Äù (Shift, double-tap, etc.) int√©gr√©e dans l‚ÄôUI.

---

=== Fonts / UI Rendering (√©tat au 2025-09-29 avant debug glitch 4x6) ===

Refonte des polices
-------------------
- Objectif : uniformiser le format des polices (√©viter 1000 formats diff√©rents).
- Mise en place :
  * Nouveau fichier `font.c/.h` centralisant les polices disponibles.
  * Fichiers de polices individuels conserv√©s (`font5x7.c/h`, `font4x6.c/h`, `font5x8_elektron.c/h`).
  * Enum `font_id_t` permettant de s√©lectionner une police :
    - FONT_5X7
    - FONT_4X6
    - FONT_5X8_ELEKTRON
  * Structure d√©crivant chaque font (`font_desc_t`) avec largeur, hauteur, pointeur sur les glyphes, etc.
- API expos√©e dans `font.h` :
  * font_get_desc(font_id) ‚Üí retourne m√©tadonn√©es de la police
  * uniformisation des glyphes en tableaux binaires index√©s par caract√®re ASCII.

UI Renderer (multi-polices)
---------------------------
- `ui_renderer.c` modifi√© pour supporter plusieurs polices.
- Politique d‚Äôaffichage :
  * Labels de pages = police 4x6 (plus compacte)
  * Labels de param√®tres = police 4x6
  * Valeurs de param√®tres = police 4x6
  * Bandeau haut (cart name, BPM, pattern) = police 5x7
  * Bandeau bas (cases Page1..5) = police 4x6
- Mise en place d‚Äôun calcul de largeur texte (en pixels) pour centrer correctement les valeurs, selon la police active.
- Cadres de param√®tres : valeur centr√©e en bas du cadre avec police 4x6.

Tests
-----
- Compilation OK avec les 3 polices int√©gr√©es (5x7, 4x6, 5x8 Elektron).
- Affichage :
  * La police 5x7 : stable et lisible.
  * La police 5x8 Elektron : affichage correct.
  * La police 4x6 : affichage "glitch√©" (bits mal align√©s).
    -> Hypoth√®se : erreur dans le d√©codage du packing (format sp√©cial 3 octets/char).
    -> Debug en cours.

√âtat global
-----------
- Tous les appels √† l‚Äôaffichage passent maintenant par `display_set_font()` et `display_draw_text()`.
- Plus besoin de protocoles sp√©cifiques par police ‚Üí syst√®me unifi√©.
- Prochaine √©tape (bloqu√©e sur bug 4x6) : corriger le d√©codage de la police 4x6.

---

### UI / Rendu OLED ‚Äî Ajustements polices & centrage (29/09/2025)

* BPM et Bank/Pattern passent en **police 4x6** (plus compacte).
* Le **titre de menu** est d√©sormais centr√© horizontalement dans l‚Äô√©cran.
* Le **nom de cartouche** est affich√© avec un fond invers√© (bloc noir + texte blanc).
* La **page active** en bas est √©galement affich√©e en invers√© pour la mettre en valeur.
* Correction de l‚Äôalignement : suppression des pixels noirs parasites entre caract√®res.

---

### UI / Param√®tres ‚Äî Cadres & valeurs (29/09/2025)

* Les 4 cadres param√®tres sont l√©g√®rement ajust√©s :

  * Haut d√©cal√© de +1 px (plus d‚Äôair en haut).
  * Bas d√©cal√© de ‚Äì1 px (plus serr√©).
* **Labels des param√®tres** : centr√©s horizontalement dans chaque cadre.
* **Valeurs des param√®tres** : centr√©es horizontalement, **remont√©es de 1 px** pour √©quilibrer le visuel.

---

### UI ‚Äî Cartouche & Pages invers√©es (29/09/2025)

* Le **nom de cartouche** affiche d√©sormais un fond rempli + texte invers√© (lisibilit√© accrue).
* Le bandeau bas a √©t√© retravaill√© :

  * La **page active** (ex. "Page3") est invers√©e.
  * Les pages inactives restent affich√©es avec un petit cadre coins ouverts.
  * Suppression du suffixe `/5` ‚Üí n‚Äôaffiche plus "1/5" mais simplement "PageX".

---

### UI ‚Äî Ic√¥ne Note + BPM invers√© (29/09/2025)

* Ajout d‚Äôune **ic√¥ne Note** (bitmap 5x9, personnalisable).
* Ic√¥ne positionn√©e dans le bandeau haut, juste avant la valeur BPM.
* Cr√©ation d‚Äôun **cadre invers√© avec marge 1 px** :

  * Quand `clock_external = true`, le BPM est affich√© en invers√© √† l‚Äôint√©rieur de ce cadre.
  * Sinon, BPM affich√© normalement (texte simple).
* Ce m√©canisme permet de diff√©rencier visuellement la clock **interne vs externe**.

---

## üìÇ R√©organisation du projet et Makefile

### üîπ Objectif
Mieux structurer le projet en regroupant les fichiers `.c` et `.h` par th√©matique dans des sous-r√©pertoires (`ui`, `drivers`, `midi`, `usb`, `apps`, `cart`, etc.), plut√¥t que d‚Äôavoir tout √† la racine.  

### üîπ Changements effectu√©s
- Tous les fichiers `ui_*.c` et `ui_*.h` d√©plac√©s dans `ui/`.
- Idem pour les fichiers `drivers/`, `midi/`, `usb/`, `apps/`, `cart/`.
- Le `Makefile` a √©t√© adapt√© pour compiler automatiquement tous les `.c` de ces dossiers.

### üîπ Makefile : correction des includes
Au lieu d‚Äôutiliser `CFLAGS += -I...` (qui est √©cras√© par ChibiOS), il faut utiliser la variable pr√©vue par le syst√®me de build :

```make
UINCDIR = usb midi drivers ui apps cart cfg

---

## UI Controller & Renderer ‚Äî Impl√©mentation compl√®te (30/09/2025)

### Contexte

Apr√®s avoir stabilis√© l‚Äôaffichage de base sur OLED (SSD1309 SPI) et les drivers boutons/encodeurs, l‚Äô√©tape suivante a √©t√© la mise en place d‚Äôune **infrastructure UI compl√®te**, inspir√©e des workflows Elektron :

* gestion d‚Äôun **√©tat UI global** (menu/page courante),
* prise en charge des **cycles de menus** (un bouton peut tourner sur plusieurs menus),
* gestion des **pages internes** (5 max par menu),
* rendu complet sur OLED avec bandeaux haut/bas, cadres de param√®tres, et centrage de labels/valeurs.

Deux fichiers principaux structurent cette UI :

* `ui_controller.c` (logique, √©tat et √©v√©nements),
* `ui_renderer.c` (affichage graphique sur OLED).

---

### üîπ Travaux r√©alis√©s (contexte complet)

#### 1. Migration des appels `cart_link_shadow_get/set`

* Ancienne API (1 param√®tre) ‚Üí remplac√©e par la nouvelle API (2 param√®tres : `cid` + `param_id`).
* Tous les appels dans `ui_controller.c` et `ui_renderer.c` corrig√©s pour passer par `cart_link_get_active()` afin de r√©cup√©rer l‚ÄôID de cartouche actif.

#### 2. Gestion des boutons menus (BM) avec cycles

* Ajout d‚Äôun moteur de cycle par bouton (`s_cycles[8]`).
* Chaque bouton peut cycler entre plusieurs menus pr√©d√©finis.
* Logique corrig√©e pour √©viter les ‚Äúsauts‚Äù intempestifs :

  * Premier appui ‚Üí s√©lection du cycle (retour √† l‚Äôentr√©e du cycle si `resume=false`).
  * Appuis suivants ‚Üí avance dans le cycle uniquement si le bouton est d√©j√† actif.
* Variable globale `g_cycle_resume_mode` introduite :

  * `true` ‚Üí on revient au dernier menu cycle actif (par d√©faut).
  * `false` ‚Üí on revient toujours au premier menu du cycle.

#### 3. Labels de pages dynamiques

* Support ajout√© pour `page_titles[]` dans chaque `ui_menu_spec_t`.
* L‚Äôaffichage en bas de l‚Äô√©cran ne montre plus `Page1‚Ä¶Page5` fixes, mais les titres sp√©cifiques √† chaque menu.
* Fallback `"‚Äì"` si un label est absent.

#### 4. Centrage du texte des labels de page

* Les labels dans le bandeau bas sont maintenant **centr√©s par rapport √† leur cadre**.
* Calcul largeur texte avec `text_width_px`.
* Fonctionne avec labels courts (‚ÄúLFO‚Äù) comme longs (‚ÄúEnvelope Pitch‚Äù).

#### 5. Shadow register (m√©moire locale des param√®tres)

* Mise en place de `g_shadow_params[CART_COUNT][MAX_DEST_ID]`.
* Chaque cartouche garde sa propre copie des param√®tres.
* Permet :

  * Toggle des bits bool√©ens (`UI_PARAM_BOOL` avec `is_bitwise=true`).
  * Consultation de l‚Äô√©tat sans relire la cartouche hardware.

---

### üîπ `ui_controller.c` ‚Äî √©tat et logique UI

* Structure `ui_state_t` centralise l‚Äô√©tat courant (cart active, menu, page, valeurs).
* **Cycles de menus** (`ui_cycle_t`) :

  * chaque bouton BM1..BM8 peut √™tre associ√© √† un cycle de 1‚Äì4 menus,
  * appui r√©p√©t√© fait tourner sur les menus du cycle,
  * option `g_cycle_resume_mode` choisit si on reprend l√† o√π on √©tait ou si on repart du premier menu.
* Fonctions principales :

  * `ui_init(spec)` ‚Äî initialise l‚ÄôUI avec la cartouche donn√©e,
  * `ui_switch_cart(spec)` ‚Äî change de cartouche,
  * `ui_on_button_menu(index)` ‚Äî gestion appui bouton menu (cycle ou simple),
  * `ui_on_button_page(index)` ‚Äî s√©lection directe de page (1..5),
  * `ui_on_encoder(enc, delta)` ‚Äî incr√©mentation des param√®tres (CONT, ENUM, BOOL) avec callback `cart_link_param_changed()`.
* Particularit√© :

  * gestion des **BOOL bitwise** (toggle d‚Äôun bit pr√©cis dans un registre shadow, puis sync via `cart_link_param_changed()`).

---

### üîπ `ui_renderer.c` ‚Äî affichage OLED complet

#### Bandeau haut

* Num√©ro de cartouche active (1..n),
* Nom de la cartouche : texte invers√© avec fond noir + marge,
* Nom du menu courant : centr√© horizontalement,
* Ic√¥ne ‚ÄúNote‚Äù 5√ó9 ajout√©e √† droite,
* Affichage BPM : normal ou invers√© si clock externe,
* Bank/Pattern affich√© en haut √† droite.

#### Cadres param√®tres

* 4 cadres (31√ó37 px) affich√©s avec coins ouverts,
* Pour chaque param√®tre actif :

  * **label** centr√© en haut (police 4√ó6),
  * **valeur** centr√©e en bas (police 4√ó6),
  * si `UI_PARAM_CONT` : rendu graphique en ‚Äúknob‚Äù circulaire (`ui_draw_knob()`).

#### Bandeau bas

* 5 emplacements pour pages,
* Pour chaque page :

  * label texte dynamique (ex. "Struct", "Env", etc.),
  * si actif ‚Üí fond invers√© (noir + texte blanc),
  * sinon ‚Üí cadre ouvert + texte normal,
* centrage horizontal appliqu√© aux labels.

#### Helpers graphiques

* `draw_rect_open_corners`, `draw_filled_rect`, `draw_hline/vline`,
* `text_width_px(font, string)` ‚Äî calcul largeur pour centrage,
* `display_draw_text_inverted_box` ‚Äî fond noir + marge autour.

---

### üîπ Probl√®mes rencontr√©s et fixes

1. **Erreur compilation `page_labels`**
   ‚Üí correction : renomm√© en `page_titles` (align√© avec spec des menus).
2. **Texte non centr√©**
   ‚Üí ajout de `text_width_px()` et calcul dynamique `(frame_w - tw)/2`.
3. **Lisibilit√© faible bandeau haut/bas**
   ‚Üí ajout inversion (fond noir + texte blanc) pour cartouche + page active.
4. **Ic√¥ne musicale**
   ‚Üí ajout√© un petit bitmap 5√ó9 (`note_icon[]`), affich√© √† c√¥t√© du BPM.
5. **Couplage UI / cycles menus**
   ‚Üí r√©solu par `ui_resolve_menu()` qui choisit dynamiquement le menu actif (cycle aware).

---

### üîπ Validation hardware

* Compilation et flash OK, √©cran SSD1309 rend :

  * cartouche en haut invers√©e,
  * nom de menu centr√©,
  * 4 cadres avec labels centr√©s + valeurs centr√©es,
  * knob dessin√© pour param√®tres continus,
  * BPM + ic√¥ne note,
  * pages en bas avec surbrillance pour la page active.
* Test interactif :

  * boutons BM1..BM8 cyclent correctement,
  * pages changent avec leurs labels en bas,
  * encodeurs modifient valeurs avec rendu en temps r√©el.

---

### üîπ √âtat actuel (30/09/2025)

‚úÖ `ui_controller.c` : cycles menus, pages, encodeurs, toggle BOOL bitwise.
‚úÖ `ui_renderer.c` : rendu complet, centrage texte, inversion, ic√¥ne BPM.
‚úÖ Architecture modulable : la logique ‚ÄúElektron‚Äù (Shift, combos, modes) sera g√©r√©e au-dessus.
‚úÖ Code structur√© et int√©gr√© dans `ui/` (Makefile mis √† jour avec `UINCDIR`).

---

### üîπ Notes pour debug futur

#### A. `cart_link_param_changed()`

* Point central de tous les envois vers la cartouche.
* Cas couverts :

  * `UI_PARAM_CONT` et `UI_PARAM_ENUM` ‚Üí valeur brute,
  * `UI_PARAM_BOOL` simple ‚Üí toggle 0/1,
  * `UI_PARAM_BOOL` bitwise ‚Üí modif via shadow register, puis envoi complet du registre.
* ‚ö†Ô∏è √Ä tester d√®s que possible : v√©rifier que `cart_set_param()` re√ßoit bien la valeur attendue.

#### B. Shadow register

* Structure : `g_shadow_params[cid][param_id]`.
* Initialis√©e √† 0 au boot (`memset`).
* Sert √† g√©rer l‚Äô√©tat local m√™me si le hardware ne r√©pond pas.
* ‚ö†Ô∏è Attention : n√©cessite une √©tape de synchronisation si la cartouche contient d√©j√† des valeurs ‚â† 0.

#### C. Strat√©gies de debug pratique

* Ajouter un `printf` dans `cart_link_param_changed()` :

  * affiche `cid`, `param_id`, `value`, `is_bitwise`, `bit_mask`.
* V√©rifier en parall√®le les valeurs dans `g_shadow_params` et les envois sur le bus.

---



# Journal de session ‚Äî UI & Cart XVA1 (30/09/2025)

## R√©sum√© op√©rationnel (ce qui marche maintenant)

* **Affichage OLED** : squelette d‚ÄôUI complet (bandeau haut, 4 cadres param√®tres, bandeau bas avec labels de pages, centrages corrig√©s).
* **Valeurs discr√®tes** : les param√®tres **ENUM/BOOL** s‚Äôaffichent avec **leurs libell√©s textes**, pas juste des nombres.
* **Cartouche XVA1** : spec scind√©e proprement en **menus individuels** (OSC1..4, Filter, ENVx, LFOx, FXx) + une cartouche `CART_XVA1` qui ne contient que **8 menus** (design ‚Äú8 boutons‚Äù + *cycles*).
* **Compilation & Link** : OK. Les erreurs ‚Äúsinf‚Äù, enums red√©clar√©s, et init de la cartouche ‚Üí **corrig√©es**.
* **Makefile** : lien avec la lib maths **`-lm`** ajout√© ‚áí `sinf()` OK.

---

## D√©tails exhaustifs (ce qu‚Äôon a chang√© / corrig√©)

### 1) Rendu OLED : centrage, inversions, ic√¥nes

* Ajout d‚Äôoutils de dessin **bas niveau** dans `ui_renderer.c` :

  * `set_pixel`, `draw_hline`, `draw_vline`, `draw_rect_open_corners`, `draw_filled_rect`.
  * calcul **largeur texte** par police : `text_width_px(font, str)` ‚Üí centrages corrects.
* **Bandeau haut :**

  * num√©ro de cartouche active (1..n),
  * **nom de cartouche** en **invers√©** (fond plein + texte blanc),
  * **nom de menu** centr√©,
  * **ic√¥ne note** 5√ó9 √† droite,
  * BPM affich√© normal ou **invers√©** (si clock externe).
* **Cadres param√®tres (x4)** :

  * cadre 31√ó37 √† ‚Äúcoins ouverts‚Äù,
  * **label** centr√© en haut (police 4√ó6),
  * **valeur** centr√©e en bas (police 4√ó6),
  * pour `UI_PARAM_CONT` : rendu **knob circulaire** via `ui_draw_knob()`.
* **Bandeau bas (pages)** :

  * 5 cases ; **label de page dynamique** (vient de la spec du menu),
  * **page active** affich√©e en invers√©, les autres avec cadre.

> Effet visible : les **enum/bool** montrent bien leurs **libell√©s textes** (ex. ‚ÄúOn/Off‚Äù, ‚ÄúPlate/Hall‚Äù, etc.) au lieu d‚Äôun entier.

---

### 2) Tables de labels (discrets) ‚Äî *Solution A : internes au .c*

> Objectif : **√©viter les doublons/extern** et √©conomiser la RAM/flash.

* **D√©cision** : toutes les tables de libell√©s **restent `static` dans `cart_xva1.c`** (une seule copie, non export√©e).
* Avantages :

  * pas d‚Äô`extern` inutiles dans le `.h`,
  * pas de symboles globaux ‚Üí pas de collisions ni ‚Äúfollows non-static declaration‚Äù,
  * le **linker** peut jeter ce qui n‚Äôest pas r√©f√©renc√© (**LTO + GC**).

Tables mises en place (repris/align√© sur tes fichiers Arduino) :

* `waveLabels[9]`
* `onOffLabels[2]`
* `syncLabels[2]`
* `keytrackLabels[2]`
* `filterTypeLabels[22]`
* `routingLabels[3]`
* `lfoWaveLabels[10]`  *(‚ö†Ô∏è bien 10, pas 9 ; on avait eu un mismatch au d√©but)*
* `lfoSyncLabels[4]`
* `egLoopLabels[2]`
* `egLoopSegLabels[2]`
* `egRstLabels[2]`
* `legatoLabels[2]`
* `portaModeLabels[3]`
* `distTypeLabels[4]`
* `gateCurveLabels[2]`
* `gainLabels[4]`
* `fxRoutingLabels[3]`
* `reverbModeLabels[2]`
* `delayModeLabels[3]`
* `chorusModeLabels[4]`
* `phaserModeLabels[3]`
* `phaseLabels[4]`
* `driveLabels[8]`
* `bandwLabels[8]`

> **Important** : on **n‚Äôexporte plus** ces tableaux dans `cart_xva1.h`. Ils sont **r√©f√©renc√©s** uniquement par les specs de param√®tres (`.meta.en={labels, count}`) dans **le m√™me fichier**.

---

### 3) Specs XVA1 : menus individuels + cartouche 8 emplacements

* Chaque sous-menu est un `const ui_menu_spec_t` autonome :

  * `XVA1_MENU_OSC1`, `XVA1_MENU_OSC2`, `XVA1_MENU_OSC3`, `XVA1_MENU_OSC4`,
  * `XVA1_MENU_FILTER`,
  * `XVA1_MENU_ENV_FILTER`, `XVA1_MENU_ENV_AMP`, `XVA1_MENU_ENV_PITCH`,
  * `XVA1_MENU_LFO12`, `XVA1_MENU_LFO_MIDIMOD`, `XVA1_MENU_MIDI_GLOBAL`,
  * `XVA1_MENU_FX1`, `XVA1_MENU_FX2`, `XVA1_MENU_FX3`, `XVA1_MENU_FX4`.
* **Cartouche** `CART_XVA1` ‚Üí **8 slots** (BM1..BM8) :
  on **place 8 menus seulement** dedans, et **on acc√®de aux autres via le *cyclage*** d√©j√† pr√©vu c√¥t√© UI (ex. BM6: ENV Filt/Amp/Pitch, BM7: LFO1&2/LFO MidiMod/Midi Global, BM8: FX1/FX2/FX3/FX4).

**Fix critique compilo** : auparavant on essayait na√Øvement d‚Äôinitialiser la cartouche avec **tous** les menus ‚Üí ‚Äúexcess elements‚Äù / initialisation incoh√©rente.
**Maintenant** : `CART_XVA1.menus = { 8 menus }` (conformes √† l‚ÄôUI *8 boutons*). Les autres sont **cycl√©s**.

---

### 4) Discrets vs continus : ce qui est affich√© **avec labels** (d√©j√† fait)

* **BOOL** : tous les bool√©ens (y compris **bitwise**) utilisent `onOffLabels` ‚Üí affichage ‚ÄúOff/On‚Äù.
* **Filter** : `Type` (22 types) & `Route` (3) ‚Üí **ENUM** avec labels.
* **LFO** :

  * `Wave` (10) ‚Üí **ENUM** `lfoWaveLabels[10]` (Tri, Sqr, SawU, SawD, ‚Ä¶, Rnd).
  * *Sync* : pour l‚Äôinstant laiss√© **CONT** (valeur brute), on pourra basculer en `lfoSyncLabels[4]` si mapp√© exactement (cf. Arduino).
* **FX** :

  * FX1 : `DistTp` (4) + `FxRout` (3) ‚Üí **ENUM**.
  * FX2 : `Mode` (2) ‚Üí **ENUM** (Plate/Hall).
  * FX3 : `Mode` (3) ‚Üí **ENUM** (Stereo/Cross/Bounce).
  * FX4 : `Mode` Chorus (4) & Phaser (3) ‚Üí **ENUM**.

> **√Ä noter** : **OSC ‚ÄúWave‚Äù** est rest√© **CONT** chez toi pour le moment (0..127). On pourra le passer en **ENUM** avec `waveLabels[9]` si la cartouche mappe bien 0..8 sur ces formes. Dis-moi si c‚Äôest le cas et je bascule.

---

### 5) BOOL bitwise : gestion propre

* Pour les bool√©ens ‚Äúbitwise‚Äù (ex. `Sync` des OSC via un registre partag√©, `EgLp/EgRst/...`), on lit/√©crit un **registre shadow** local puis on envoie la nouvelle valeur via `cart_link_param_changed()`.
* Rendu UI : valeur affich√©e **Off/On** (ou labels d√©di√©s si fournis) **et** bit correct envoy√© sous-jacemment.

---

### 6) `ui_widgets.h` : conflit d‚Äôenum corrig√© (alias)

* Probl√®me : on red√©clarait `UI_PARAM_CONT/ENUM/BOOL` dans `ui_widgets.h` ‚Üí **conflits** avec `ui_spec.h`.
* **Fix** : `ui_widgets.h` inclut `ui_spec.h` et fait :

  ```c
  typedef ui_param_kind_t ui_param_kind_for_router_t;
  ```

  ‚Üí plus aucune red√©claration, toutes les comparaisons `ps->kind == UI_PARAM_ENUM` etc. compilent proprement.

---

### 7) `sinf()` : include + linkage

* `ui_widgets.c` utilisait `sinf()` (pour dessiner la sinuso√Øde), mais :

  * **include manquant** ‚Üí `#include <math.h>`,
  * **link math** manquant ‚Üí Makefile : `ULIBS += -lm`.
* **R√©sultat** : plus d‚Äô‚Äúundefined reference to `sinf`‚Äù.

---

### 8) Stray `return` dans `ui_widgets.c`

* Il y avait un `return 0;` **hors fonction** (ligne ~165) ‚Üí **erreur de parse**.
* **Supprim√©**. Le fichier compile.

---

### 9) Warnings : ce qu‚Äôon laisse, ce qu‚Äôon supprime

* `-Wunused-const-variable` sur certaines tables (ex. `legato`, `portaMode`) si pas encore utilis√©es par des params ENUM : **sans gravit√©**.
  *On pourra soit les utiliser bient√¥t (quand on mappe ces param√®tres), soit les retirer si finalement non utilis√©s.*
* `excess elements in array initializer` sur `CART_XVA1` : **corrig√©** en limitant √† 8 menus.
* ‚ÄúOptions to '-Xassembler' do not match‚Äù (LTO) : **warning ld-wrapper** de GCC sous Windows ; sans impact fonctionnel sur le binaire.

---

## Points d‚Äôarchitecture clarifi√©s

### A) Pourquoi **8 menus** dans `CART_XVA1` ?

* Le hardware expose **8 boutons ‚Äúbanks/menus‚Äù** (BM1..BM8).
* Le design UI est **Elektron-like** : **chaque bouton** peut **cycler** entre **plusieurs menus**.
* Donc la cartouche **ne contient que 8** `ui_menu_spec_t` ; les **autres** sont accessibles par **cycle** (d√©j√† c√¢bl√© c√¥t√© `ui_controller`).

### B) M√©moire c√¥t√© interface

* Garder les **labels en `static const` dans le `.c`** est **le plus √©conome** :

  * **une seule copie**,
  * **pas d‚Äôextern** donc pas de r√©f√©rences inutiles,
  * le **linker** peut ‚Äúgarbage-collecter‚Äù ce qui n‚Äôest pas utilis√©.
* Passer `Wave/Type/etc.` en **ENUM** n‚Äôaugmente pas la RAM ; √ßa **pointe** vers un tableau de `const char*` d√©j√† en flash.

---

## Ce qui reste √† faire (prioris√©)

1. **OSC Wave ‚Üí ENUM (si mappage confirm√©)**

   * Passer `Wave` (OSC1..4) de `CONT` ‚Üí `ENUM` avec `waveLabels[9]` si la cartouche mappe bien 0..8 (SawUp..Stk7s).
   * Sinon : garder `CONT`, mais **afficher** un pseudo-label (ex. ‚ÄúWxx‚Äù) ‚Üí *moins bien*.

2. **Tune/Transp ‚Üí libell√©s musicaux**

   * Aujourd‚Äôhui : valeurs brutes **0..127** affich√©es.
   * √Ä faire : affichage **¬±semitones** (ex. ‚Äú-7 st‚Äù, ‚Äú+3 st‚Äù), ou ‚ÄúC‚Ä¶B‚Äù si tu veux des **notes**.
   * **C√¥t√© protocole XVA1** : on pr√©pare la mont√©e √† **0..255** (8 bits) ‚Üí on ajustera `.meta.range={0,255,1}` menu par menu.

3. **LFO Sync ‚Üí ENUM**

   * Passer `Sync` des LFO en `ENUM` `lfoSyncLabels[4]` (1FR/1KS/MFR/MKS) si le mappage √† 4 √©tats est confirm√© c√¥t√© cartouche.

4. **Autres discrets**

   * Mapper le reste (porta mode, legato, phases, drive, bandwidth, etc.) d√®s qu‚Äôon branche les pages correspondantes.

5. **Widgets ‚Äúdessin‚Äù pour labels discrets**

   * Ic√¥nes **waveforms** (sine/saw/square/tri/noise),
   * **Switch** on/off,
   * **Types de filtres** (pictos simplifi√©s LP/HP/BP/‚Ä¶),
   * **S√©q mode** (plus tard).
   * On garde l‚Äôarchitecture **modulaire** : **picking** auto d‚Äôun widget par **type** (BOOL/ENUM/CONT) + **override** via une **binding table** (menu/page/slot ‚Üí widget).

6. **Protocole XVA1 8-bits (UART) ‚Äî c√¥t√© UI**

   * Aujourd‚Äôhui, les ranges sont souvent `0..127`.
   * D√®s qu‚Äôon bascule la cartouche au **protocole XVA1 (0..255)**, je passe les `.meta.range` √† `0..255` dans les menus concern√©s.

---

## Mode d‚Äôemploi rapide (ajouter un discret avec labels)

1. Dans `cart_xva1.c`, **en haut** :

   ```c
   static const char* const myLabels[3] = { "A","B","C" };
   ```

2. Dans le menu concern√© :

   ```c
   { "Mode", UI_PARAM_ENUM, <ID>, 0, .meta.en={ myLabels, 3 } },
   ```

3. **Recompiler**. Pas d‚Äôupdate `.h` n√©cessaire.

---

## Notes Build

* **Makefile** : ajouter la lib maths pour `sinf()`

  ```
  ULIBS += -lm
  ```
* **Includes** :

  * `ui_widgets.c` : `#include <math.h>`
  * **ne pas** red√©clarer les enums `UI_PARAM_*` ; inclure `ui_spec.h` et utiliser le typedef alias.

---

## Validation observ√©e

* Apr√®s corrections : `make -j8` ‚Üí **OK** (0 error).
* Warnings restants uniquement sur *const non utilis√©s* (normaux tant que tout n‚Äôest pas mapp√©).
* **Affichage** : ENUM/BOOL montrent leurs **libell√©s** ; CONT montrent les **valeurs** ; **knob** pour CONT ; **pages dynamiques** OK ; **cart name/menu** OK.

---

## Prochaines sessions (plan)

1. **Passage 0..255** (XVA1 UART) menu par menu (ranges + envoi).
2. **Libell√©s musicaux** pour `Tune/Transp`.
3. **Widgets graphiques** pour ENUM/BOOL (ondes, filtres, switch).
4. **Binding table** (override par menu/page/slot).
5. **Modes SEQ custom** (bouton SEQ) **reuse du squelette UI** ‚Üí plug & play.

---

**TL;DR** :
On a **fiabilis√©** le rendu OLED, **corrig√©** la toolchain (math, enums, cart init), **branch√©** des **libell√©s complets** pour les discrets importants, **nettoy√©** l‚Äôexport des labels (Solution A), et **retenu** l‚Äôarchitecture ‚Äú8 boutons + cycles‚Äù.
La base est pr√™te pour **√©tendre** (0..255, widgets custom, labels musicaux) sans re-casser l‚ÄôUI.
