Résumé exécutif

    Les macros pool sont présentes et l’offset 16 bits est garanti, mais SEQ_FEATURE_PLOCK_POOL_STORAGE reste à 0 tant que la cible n’appelle pas fw-pooled, et la limite 24 p-locks/UI n’est pas alignée sur les 20 attendus.

La sérialisation PLK2 émet/charge le triplet {id,val,flags} dans l’ordre du pool avec warnings sur les anomalies, mais les erreurs de decode ne sont pas propagées au chargeur.

Le Reader passe bien par le pool avant le chemin legacy et ne re-décode plus en 32 bits.

Les writers UI/Live dédupliquent et commitent en un appel, mais le tampon UI reste dimensionné à 24 et la piscine ne possède aucun reset runtime, ce qui risque une croissance monotone.

Les reliques legacy sont confinées derrière #if !SEQ_FEATURE_PLOCK_POOL et protégées par #pragma poison, mais le flag SEQ_PROJECT_LEGACY_CODEC n’existe pas encore.

Côté hot/cold, aucun apps/ n’inclut ch.h, les buffers hold restent hors .ram4 et les audits CCRAM sont toujours actifs.
1) Flags & configuration “pool”

    Constat code. SEQ_FEATURE_PLOCK_POOL et les bornes piste/step/20 p-locks sont posés dans seq_config.h; la piscine statique s_pool[] + _Static_assert 16 bits sont en place, mais SEQ_FEATURE_PLOCK_POOL_STORAGE n’est monté à 1 que via la cible fw-pooled et SEQ_MODEL_MAX_PLOCKS_PER_STEP reste à 24 (tampons UI/Live idem).

Référence attendue. Les docs exigent activation par défaut (SEQ_FEATURE_PLOCK_POOL{,_STORAGE}=1), refs 3 o (offset,count) et ≤ 20 p-locks/step.

Écart / risque. Build générique sans cible dédiée compile avec le stockage OFF, les buffers acceptent 24 entrées et la capacité calculée (×20) peut être dépassée silencieusement. SEQ_PROJECT_LEGACY_CODEC n’existe pas pour verrouiller l’ancien flux.

    Recommandation. Définir SEQ_FEATURE_PLOCK_POOL_STORAGE=1 dans la config firmware par défaut, ramener SEQ_MODEL_MAX_PLOCKS_PER_STEP (et les buffers UI/Live) à SEQ_MAX_PLOCKS_PER_STEP, introduire le flag SEQ_PROJECT_LEGACY_CODEC pour contrôler explicitement l’ancien codec.

2) Sérialisation PLK2

    Constat code. L’encodeur écrit PLK2 + count + triplets issus du pool, les décodeurs vérifient taille, max=20, OOM et injectent via seq_plock_pool_alloc/get, laissant pl_ref={0,0} sur erreur.

Référence attendue. PLK2 doit suivre la spéc (count u8, triplets, ordre encode=ordre Reader, warning sur invalides, OOM → warn + pl_ref nul).

Écart / risque. Les résultats PLK2_DECODE_* sont ignorés : le chargeur poursuit même après OOM/invalid, sans remonter de statut ou rollback global.

    Recommandation. Propager le statut de decode_plk2_chunk au chargeur (trace + traitement policy), et envisager un reset piscine lors du chargement d’un track/pattern pour éviter la dérive cumulative.

3) Reader pool-first

    Constat code. seq_reader_plock_iter_open/next basculent vers seq_plock_pool_get(off,i) dès que pl_ref.count>0; sinon le chemin legacy reste disponible. Aucun remap/tri supplémentaire ni élargissement 32 bits.

Référence attendue. Reader hot-only consommant d’abord le pool et respectant l’ordre PLK2.

    Écart / risque. RAS fonctionnellement ; seul subsiste le fallback legacy pour les builds sans pool.

    Recommandation. Garder ce chemin en l’état mais prévoir, côté tests, une couverture d’itération mixte (steps sans p-locks) pour verrouiller la priorité pool.

4) Writers UI / Live Rec

    Constat code. Les buffers collectent via le Reader, dédupliquent “dernier gagnant”, limitent la taille, et un seul appel seq_model_step_set_plocks_pooled commit (avec rollback snapshot + warn sur OOM).

Référence attendue. Writers pooled, multi-hold best-effort, aucun drop NOTE_OFF/CC123, OOM → warn + rollback.

Écart / risque. Les tampons autorisent 24 entrées, dépassant la limite doc et la capacité pool calculée, et seq_model_step_set_plocks_pooled ne libère jamais les blocs lorsque le nombre change : la piscine ne reset pas durant l’usage (aucun appel hors tests), menant à un remplissage monotone.

    Recommandation. Réduire les buffers à 20, faire appliquer cette borne dans seq_model_step_set_plocks_pooled, et introduire un seq_plock_pool_reset() lors des resets projet/track pour éviter la fuite monotone.

5) Reliques legacy & “poison”

    Constat code. Les fonctions legacy (add/remove/get, plock_count) ne sont compilées que quand le pool est OFF et sont marquées #pragma GCC poison; les codecs decode_track_steps_v1/v2 sont toujours présents pour compat V1/V2.

Référence attendue. Migration progressive avec poison limité aux APIs legacy.

    Écart / risque. Absence de SEQ_PROJECT_LEGACY_CODEC complique la désactivation explicite de la voie héritée.

    Recommandation. Introduire le flag manquant pour conditionner clairement la voie legacy (et documenter l’état dans ARCHITECTURE_FR.md).

6) Barrière hot/cold et dépendances UI

    Constat code. Aucun fichier apps/ n’inclut ch.h; le pont LED manipule des snapshots + Reader, hold slots placés via macro neutre (CCM_DATA redéfini vide) ; pas d’appel seq_runtime_cold_* ni d’accès direct cold dans le tick UI.

Référence attendue. UI Reader-only, pas de RTOS côté apps, CCRAM neutralisée.

    Écart / risque. RAS identifié ; les pointeurs track restent obtenus via la façade seq_access.

    Recommandation. Continuer à limiter les includes UI à seq_access.h et surveiller les accès à g.track (penser à la future façade handles cold/hot).

7) RAM/sections (inspection déclarative)

    Constat code. Les symboles hold/cart sont en SRAM standard (CCM_DATA vide), aucune annotation .ram4; les scripts d’audit CCRAM restent fournis et valident VMA/NOLOAD via tools/check_ccram.py & tools/audit/*.

Référence attendue. .ram4 neutralisée, audits actifs, budget hot surveillé.

    Écart / risque. Aucun : la section .ram4 est toujours vide par design.

    Recommandation. Conserver les audits NOLOAD et, à la prochaine passe mémoire, documenter tout éventuel retour en CCRAM.

Conclusion

Le socle pool/PLK2 est opérationnel (encode/Reader/Writers) mais plusieurs verrous restent ouverts : activation storage dépendante du build, buffers 24 entrées, absence de reset piscine et statut decode PLK2 silencieux. Les prochaines passes devraient (i) fixer la config par défaut (pool storage + bornes 20), (ii) ajouter un cycle de vie clair pour la piscine (reset sur load/clear), (iii) exposer le flag SEQ_PROJECT_LEGACY_CODEC, puis (iv) renforcer la détection d’erreurs PLK2. Propositions de passes :

    Pass A : aligner les bornes (20) + reset piscine + statut decode.

    Pass B : introduire le flag legacy codec et mettre à jour la doc/CI.

    Pass C : audit de long terme (soak) pour valider absence de fuite après reset.

Suggestion doc. Ajouter dans ARCHITECTURE_FR.md une note temporaire rappelant que SEQ_FEATURE_PLOCK_POOL_STORAGE reste désactivé tant que la cible legacy est supportée et qu’un reset piscine est requis à chaque load, afin d’aligner la spec sur l’état actuel jusqu’à correction.

Aucun test ni build exécuté (conformément au mandat)


1. Résumé exécutif

Verdict : suppression totale du legacy = KO. Deux blocs bloquent le cutover PLK2-only / pool-only :

    Reader continue d’adresser step->plocks[] / plock_count même quand SEQ_FEATURE_PLOCK_POOL=1, ce qui casserait la compilation dès que les symboles legacy sont empoisonnés et fait mentir la spec “Reader pool-first” de l’architecture.

Codec projet : la lecture/écriture appelle toujours decode_track_steps_v1/v2 et sérialise les tableaux legacy, les tests host attendent même l’absence de chunk PLK2. En coupant V1/V2 on perd la capacité à charger des patterns et on viole la feuille de route PLK2-only.

Sans résoudre ces points, l’activation simultanée de SEQ_PROJECT_LEGACY_CODEC=0, SEQ_ENABLE_PLOCK_LEGACY_POISON=1 et SEQ_FEATURE_PLOCK_POOL_STORAGE=1 brisera compilation et persistance.
2. Carte d’impact
#	Symbole / dépendance legacy	Fichier · lignes	Rôle (UI/loader/tests…)	Remplacement pooled attendu	Risque si legacy supprimé
1	legacy_step->plocks, plock_count dans seq_reader_plock_iter_* et seq_reader_pl_next	core/seq/reader/seq_reader.c L324‑451
Reader hot path (UI, runner, tests)	Itérer exclusivement sur (pl_ref.offset,count) via seq_plock_pool_get() y compris quand count==0	Compilation KO (pragma poison), Reader inutilisable
2	decode_track_steps_v1/v2, encode_track_steps_v1/v2, stockage plocks[]	core/seq/seq_project.c L711‑1055
Chargement/sauvegarde patterns	Nouveau codec “V3” ou PLK2-only qui reconstruit le pool et alimente pl_ref	Patterns illisibles / impossible de sauver en PLK2-only
3	Tests test_load_plk2_missing_fallback_legacy (et similaires) qui exigent le chemin tableau	tests/test_load_plk2_missing_fallback_legacy.c L8‑55
Validation host	Adapter les tests pour générer/attendre des triplets PLK2	Campagne host échoue (assertions legacy)
4	_legacy_extract_plock_payload et champs state->plocks (Reader)	core/seq/reader/seq_reader.c L35‑116 & L353‑451
Encodage UI/runner des IDs 16 bits	LUT 3 o → 16 bits commune au pool, sans dépendance tableau	Behaviour Reader incohérent, impossibilité d’encoder les p-locks
3. UI / Live Rec

    Toutes les écritures multi-step (hold) collectent les p-locks via seq_reader_pl_open/next et commitent un unique seq_model_step_set_plocks_pooled(...) ; le chemin legacy n’est conservé que sous #if !SEQ_FEATURE_PLOCK_POOL.

Live Rec lit les triplets existants par Reader, bufferise les mutations (_seq_live_capture_collect_plocks) puis commit via seq_model_step_set_plocks_pooled; l’upsert legacy est entièrement dans le #else.

Hold/multi-hold et l’inversion OLED reposent bien sur l’état Reader (pool-first) après commit et ne relisent plus les tableaux legacy.

Live capture n’écrit plus directement dans un tableau legacy en mode pool : seules les branches #else héritées subsistent pour SEQ_FEATURE_PLOCK_POOL=0.

➡️ UI et Live Rec sont prêts pour un run-time pool-only ; aucun blocage identifié côté writers.
4. Reader

    seq_reader_plock_iter_open/next assignent toujours legacy_step->plocks et plock_count avant de vérifier pl_ref, ce qui déclenchera immédiatement les #pragma GCC poison avec la configuration kill switch.

_legacy_extract_plock_payload reste la source d’encodage 16 bits ; sans tableau, les itérateurs ne renverront plus rien pour les steps “pool-only”.

Le Reader ne propose pas encore d’encodeur LUT 3 o → format 16 bits comme prévu par la carte de migration.

➡️ Tant que ces accès ne sont pas refactorés, le Reader n’est pas compatible pool-only.
5. Sérialisation (PLK2-only)

    encode_plk2_chunk et decode_plk2_chunk gèrent bien {id,val,flags} et remplissent pl_ref.

MAIS seq_project_track_steps_decode route toujours vers decode_track_steps_v1/v2 en fonction du numéro de version, puis n’utilise PLK2 que comme supplément facultatif. Aucun chemin ne traite “PLK2 seul”.

Les encodeurs V1/V2 continuent d’écrire les tableaux legacy (branchés sous #if !SEQ_FEATURE_PLOCK_POOL), ce qui empêche de générer un payload minimal PLK2-only.

Les tests host valident explicitement l’absence de chunk PLK2 et que pl_ref.count==0, confirmant la dépendance legacy.

➡️ Couper les codecs V1/V2 aujourd’hui rendrait impossible le chargement/sauvegarde des patterns.
6. Garde-fous produit

    Hot/cold : aucune inclusion de ch.h dans apps/, conformité no cold in TICK préservée.

MIDI invariants : Les writers étudiés (UI, Live Rec) restent confinés au modèle/Reader et ne publient pas de MIDI direct, conforme à SEQ_BEHAVIOR.md (NOTE_OFF jamais droppé, P-lock avant NOTE_ON).

Sections mémoire : aucune déclaration .ram4 / CCMRAM dans le code p-lock (scan négatif).

Docs d’autorité : la migration attendue (pool packé 3 o, Reader pool-first) correspond aux objectifs décrits dans docs/ARCHITECTURE_FR.md (§Reader) et docs/PLOCK_MIGRATION_MAP.md.
7. Plan minimal de cutover (micro-deltas)

    Reader → pool only

        core/seq/reader/seq_reader.c: remplacer l’initialisation de s_plock_iter_state par une branche unique basée sur pl_ref, supprimer legacy_step->plocks/plock_count, introduire une LUT {id,val,flags} → 16 bits pour _legacy_extract_plock_payload.

Adaptation itérateur Reader rapide

    core/seq/reader/seq_reader.c: revoir seq_reader_pl_next pour qu’il retourne 0 directement quand pl_ref.count==0, sans toucher aux tableaux supprimés. Ajouter une fonction d’encodage pool→Reader (à partager avec l’UI).

Codec projet PLK2-only

    core/seq/seq_project.c: introduire un parseur “V3” (ou version=3) qui consomme uniquement le chunk PLK2 et peuple pl_ref; réécrire track_steps_encode_internal pour générer ce chunk sans écrire V1/V2 ; désactiver decode_track_steps_v1/v2 via #if/suppression quand SEQ_PROJECT_LEGACY_CODEC=0.

    Campagne tests

        tests/test_load_plk2_*: mettre à jour les fixtures pour produire un chunk PLK2 (avec seq_model_step_set_plocks_pooled) et supprimer les assertions sur pl_ref.count==0. Idem pour les autres tests orientés tableau.

    Activer le kill switch

        Modifier la configuration (Makefile / CI) pour builder par défaut avec SEQ_PROJECT_LEGACY_CODEC=0, SEQ_ENABLE_PLOCK_LEGACY_POISON=1, SEQ_FEATURE_PLOCK_POOL=1, SEQ_FEATURE_PLOCK_POOL_STORAGE=1, vérifier que la compilation passe et que les tests host couvrent le parcours PLK2.

8. Conclusion binaire

    Le pool/PLK2 n’est pas encore prêt à être seul : il manque 4 ponts critiques (Reader sans fallback, codec V3, adaptation des tests, kill-switch build) pour respecter la spec pool-first et PLK2-only. Voir blocages #1–#4 ci-dessus.

9. Annexe — emplacements à traiter

    Reader legacy → pool : lignes 324‑451 de core/seq/reader/seq_reader.c (suppression de legacy_step->plocks / _legacy_extract_plock_payload).

Encodeur PLK2 : lignes 376‑418 (écriture) et 253‑338 (lecture) de core/seq/seq_project.c — point de rattachement d’un codec pur triplets.

Décodage V1/V2 à retirer : lignes 711‑1055 de core/seq/seq_project.c.

Tests legacy : lignes 8‑55 de tests/test_load_plk2_missing_fallback_legacy.c.

(Aucun test ni build n’a été lancé pour cette analyse.)
